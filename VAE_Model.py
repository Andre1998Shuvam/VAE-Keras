# -*- coding: utf-8 -*-
"""Variational_Auto_Encoders.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kjsoW0bQUuY7hWbnYNIkW0CfSyIi_QRA
"""

import keras
import numpy as np
#from tensorflow.examples.tutorials.mnist import input_data
import tensorflow as tf
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Lambda,Dense,Input
import tensorflow.keras.backend as K

m=50
#Dimension of latent variables(n_z) 
n_z=2
epochs=100

inputs=Input(shape=(784,))
h1=Dense(512,activation='relu')(inputs)
mean=Dense(n_z,activation='linear')(h1)
variance=Dense(n_z,activation='linear')(h1)
mean
inputs

def sampling_z(args):
    u,log_sigma=args
    eps = K.random_normal(shape=(m, n_z,),mean=0,stddev=1)
    print(eps)
    return u+K.exp(log_sigma)*eps

z=Lambda(sampling_z)([mean,variance])
#sampling_z([mean,variance])

z

decoder_hidden=Dense(512,activation='relu')
decoder_out=Dense(784,activation='sigmoid')

h_p = decoder_hidden(z)
outputs = decoder_out(h_p)
mean
outputs.shape

#The three models for implementation of VAEs in Keras

#Training Model
vae=Model(inputs,outputs)

#Encoder
encoder=Model(inputs,mean)



#Decoder
d_in = Input(shape=(n_z,))
d_h = decoder_hidden(d_in)
d_out=decoder_out(d_h)
decoder=Model(d_in,d_out)
decoder.__dict__
d_out
vae.summary()



def vae_loss(y_true, y_pred):
    """ Calculate loss = reconstruction loss + KL loss for each data in minibatch """
    # E[log P(X|z)]
    #print(y_true.shape,y_pred.shape)
    recon = K.sum(K.square(y_pred-y_true), axis=1)
    # D_KL(Q(z|X) || P(z|X)); calculate in closed form as both dist. are Gaussian
    kl = 0.5 * K.sum(K.exp(variance) + K.square(mean) - 1. - variance, axis=1)
    #print(kl)
    #recon= K.sum(K.square(y_pred-y_true))
	# compute the KL loss
    #kl= - 0.5 * K.sum(1 + variance - K.square(mean) - K.exp(variance), axis=-1)
    return K.mean(recon + kl)

mnist = tf.keras.datasets.mnist

(x_train, y_train),(x_test, y_test) = mnist.load_data()
x_train, x_test = x_train / 255.0, x_test / 255.0
x_train[0].shape
x_train=x_train.reshape(60000,784)
x_train[50].shape

vae.compile(optimizer='adam',loss=vae_loss,metrics=['accuracy'])
vae.fit(x_train, x_train, batch_size=m, epochs=20)

vae

decoder.summary()

vae.summary()
x_test=x_test.reshape(10000,784)

pred=vae.predict(x_train,batch_size=m)

pred[0].shape

import matplotlib.pyplot as plt
pred[0].shape
pred=pred.reshape(60000,28,28)
x_train=x_train.reshape(60000,28,28)
pred.shape

plt.imshow(pred[10],cmap='gray')

plt.imshow(x_train[10],cmap='gray')

decoder.summary()

import numpy as np
n = 30
digit_size = 28
figure = np.zeros((digit_size * n, digit_size * n))
grid_x = np.linspace(-4, 4, n)
grid_y = np.linspace(-4, 4, n)[::-1]

for i, yi in enumerate(grid_y):
    for j, xi in enumerate(grid_x):
        z_sample = np.array([[xi, yi]])
        x_decoded = decoder.predict(z_sample)
        digit = x_decoded[0].reshape(digit_size, digit_size)
        figure[i * digit_size: (i + 1) * digit_size,
               j * digit_size: (j + 1) * digit_size] = digit

plt.figure(figsize=(10, 10))
start_range = digit_size // 2
end_range = n * digit_size + start_range + 1
pixel_range = np.arange(start_range, end_range, digit_size)
sample_range_x = np.round(grid_x, 1)
sample_range_y = np.round(grid_y, 1)
plt.xticks(pixel_range, sample_range_x)
plt.yticks(pixel_range, sample_range_y)
plt.xlabel("z[0]")
plt.ylabel("z[1]")
plt.imshow(figure, cmap='Greys_r')

x_test_encoded = encoder.predict(x_test, batch_size=m)
plt.figure(figsize=(6, 6))
plt.scatter(x_test_encoded[: ,0], x_test_encoded[: ,1], c=y_test)
plt.colorbar()
plt.show()

n = 15  # figure with 15x15 digits
digit_size = 28
figure = np.zeros((digit_size * n, digit_size * n))
# we will sample n points within [-15, 15] standard deviations
grid_x = np.linspace(-15, 15, n)
grid_y = np.linspace(-15, 15, n)

for i, yi in enumerate(grid_x):
    for j, xi in enumerate(grid_y):
        z_sample = np.array([[xi, yi]]) * 1
        x_decoded = decoder.predict(z_sample)
        digit = x_decoded[0].reshape(digit_size, digit_size)
        figure[i * digit_size: (i + 1) * digit_size,
               j * digit_size: (j + 1) * digit_size] = digit

plt.figure(figsize=(10, 10))
plt.imshow(figure,cmap='gray')
plt.show()


